(*
  -- Grammar for Homescript --

  Author: RubixDev
  Contributors: MikMuellerDev

  This grammar is written in the EBNF notation defined by the ISO/IEC 14977 standard.
  A lesser known feature of that standard is used here: the `{ ... }-` syntax
  to describe a repetition of *one* or more times instead of the usual *zero* or more times
  represented by `{ ... }`. This is actually just the exclusion (represented by the `-`) of
  the empty sequence (because nothing follows the `-`) from the `{ ... }` repetition.

  Whenever a symbol is referenced in a comment its name is enclosed in angle brackets (< and >).
  The naming convention chosen here is PascalCase for context-free rules, snake_case for
  regular rules, also known as nonterminals, and SCREAMING_SNAKE_CASE for sets of terminal
  symbols.
*)

(*
  Start symbol:
  Program consists of any amount of <Statement>s each followed by a ';'
*)
Program = { Statement , ';' } ;

(**************************)
(******* STATEMENTS *******)
(**************************)
Statement    = LetStmt
             | ImportStmt
             | BreakStmt
             | ContinueStmt
             | ReturnStmt
             | Expression ;
(*
  A <LetStmt> is used to create new variables in the current scope. Variables propagate
  up to inner scopes, but can be shadowed by declaring a new variable with the same name.
  When no expression is provided, a value of `null` will be assigned to the new variable.
*)
LetStmt      = 'let' , identifier , [ '=' , Expression ] ;

(*
A <ImportStmt> is used to bring a function from another Homescript into the current scope.
Such statement can be used everywhere, even in functions, but such use is highly discouraged.
Instead the convention is to import the required functions at the very top of a Homescript.
An import of a specific function should only be performed once.
When a functions name conflicts with another name in the current scope, `as` can be used to
import the target function under a different specified name.
*)

ImportStmt  = 'import', identifier, [ 'as', identifier ], 'from', identifier ;


(*
  A <BreakStmt> is used to stop a loop entirely. It can optionally be followed by an
  expression that will be used as the loop's resulting value.
*)
BreakStmt    = 'break' , [ Expression ];
(*
  A <ContinueStmt> is used to skip to the next iteration of the current loop.
*)
ContinueStmt = 'continue' ;
(*
  A <ReturnStmt> is used to stop the currently running function. It can optionally be
  followed by an expression that will be used as the function's return value.
*)
ReturnStmt   = 'return' , [ Expression ] ;

(***************************)
(******* EXPRESSIONS *******)
(***************************)
Expression = OrExpr ;
OrExpr     = AndExpr , { '||' , AndExpr } ;
AndExpr    = EqExpr , { '&&' , EqExpr } ;
EqExpr     = RelExpr , [ ( '==' | '!=' ) , RelExpr ] ;
RelExpr    = AddExpr , [ ( '<' | '>' | '<=' | '>=' ) , AddExpr ] ;
AddExpr    = MulExpr , { ( '+' | '-' ) , MulExpr } ;
MulExpr    = CastExpr , { ( '*' | '/' | '%' ) , CastExpr } ;
CastExpr   = UnaryExpr , [ 'as' , type ] ;
UnaryExpr  = ( '+' | '-' | '!' ) , UnaryExpr
           | ExpExpr ;
ExpExpr    = AssignExpr , [ '**' , UnaryExpr ] ;
(*
  Assignments, defined by <AssignExpr>, mutate an existing value by assigning
  a new value to it. The new value is also the result of this expression.
*)
AssignExpr = CallExpr , [ ASSIGN_OPERATOR , Expression ] ;
ASSING_OPERATOR = '=' | '*=' | '/=' | '%=' | '+=' | '-=' | '**=' ;
(*
  A <CallExpr> tries to call the given value as a function with supplied arguments.
  The result is the return value of the called function.
*)
CallExpr   = MemberExpr , [ Args , { CallExprPart } ] ;
(*
  A <MemberExpr> accesses fields of a value. The only types that have fields are
  `Pair` and `Time`.
*)
MemberExpr = Atom , { MemberExprPart } ;
MemberExprPart = '.' , identifier ;
CallExprPart   = MemberExprPart | Args ;
Atom       = number
           | bool
           | string
           | PairExpr (* <- also starts with <string>, but identifiable by the following `=>` *)
           | 'null'
           | identifier
           | IfExpr
           | ForExpr
           | WhileExpr
           | LoopExpr
           | FnExpr
           | TryExpr
           | '(' , Expression , ')' ;
(*
  A <PairExpr> creates a value of type `Pair` given a <string> as the key and an
  arbitrary <Expression> for the value. `Pair`s are used in the builtin `exec` and
  `http` functions. Additionaly, the key and value of a pair can be accessed through
  the `k` and `v` fields respectively. An example might look like this:

  ```
  let my_pair = 'my_key' => 42;
  assert(my_pair.k == 'my_key');
  assert(my_pair.v == 42);
  ```
*)
PairExpr   = string , '=>' , Expression ;
(*
  A <Block> always creates a new scope for variables. It contains a sequence
  of <Statement>s and returns the result of the one after the last semicolon,
  or `null` otherwise.
*)
Block      = '{' , [ Statement , { ';' , Statement } , [ ';' ] ] , '}' ;
(*
  An <IfExpr> checks a condition and executes code based on whether that condition
  evaluates to `true` or `false`. The resulting value is the result of the executed
  <Block>, either the `if` or `else` block. When the condition evaluates to `false`
  and no `else` <Block> is specified, the result will be `null`.
*)
IfExpr     = 'if' , Expression , Block , [ 'else' , ( IfExpr | Block ) ] ;
(*
  A <ForExpr> loops over the given (inclusive) range of numbers, assigning the current
  number to the given <identifier> inside the <Block> for each iterations.
  The resulting value is set by a <BreakStmt> inside the loop, or `null` if no
  <BreakStmt> was encountered. An example might look like the following:

  ```
  for i in 3..5 {
      print(i);
  };
  # output:
  # 3
  # 4
  # 5
  ```
*)
ForExpr    = 'for' , identifier , 'in' , Expression , '..' , Expression , Block ;
(*
  A <WhileExpr> loops the given <Block> as long as the condition evaluates to `true`.
  The resulting value is set by a <BreakStmt> inside the loop, or `null` if no
  <BreakStmt> was encountered.
*)
WhileExpr  = 'while' , Expression , Block ;
(*
  A <LoopExpr> loops the given <Block> forever.
  The resulting value is set by a <BreakStmt> inside the loop, or `null` if no
  <BreakStmt> was encountered.
*)
LoopExpr   = 'loop' , Block ;
(*
  An <FnExpr> creates a value of type `Function` that defines a block of code
  to be called at a later point in the script. An example usage might look like
  the following:

  ```
  let add_one = fn(x) {
      x + 1
  };
  assert(add_one(3) == 4);
  ```
*)
FnExpr     = 'fn' , identifier , ArgNames , Block ;
(*
  A <TryExpr> executes some block of code and catches any error that might occur.
  The thrown error is then assigned to the <identifier> and the catch block is run.
*)
TryExpr    = 'try' , Block , 'catch' , identifier , Block ;

Args     = '(' , [ Expression , { ',' , Expression } , [ ',' ] ] , ')' ;
ArgNames = '(' , [ identifier , { ',' , identifier } , [ ',' ] ] , ')' ;

(**********************************)
(******* NONTERMINAL TOKENS *******)
(**********************************)
number      = DIGIT , { DIGIT } , [ '.' , DIGIT , { DIGIT } ] ;
string      = '"' , { CHAR - ( '"' | '\' ) | escape_seq } , '"'
            | "'" , { CHAR - ( "'" | '\' ) | escape_seq } , "'" ;
escape_seq  = '\' , ( ESCAPE_CHAR
                    | 3 * OCTAL
                    | 'x' , 2 * HEX
                    | 'u' , 4 * HEX
                    | 'U' , 8 * HEX ) ;
bool        = 'true' | 'false' | 'on' | 'off' ;
type        = 'str' | 'bool' | 'num' | 'null' ;
identifier  = ( LETTER , { LETTER } ) - ( bool | type | ? any keyword ? ) ;

(************************************)
(******* TERMINAL SYMBOL SETS *******)
(************************************)
LETTER      = 'A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G' | 'H' | 'I' | 'J'
            | 'K' | 'L' | 'M' | 'N' | 'O' | 'P' | 'Q' | 'R' | 'S' | 'T'
            | 'U' | 'V' | 'W' | 'X' | 'Y' | 'Z'
            | 'a' | 'b' | 'c' | 'd' | 'e' | 'f' | 'g' | 'h' | 'i' | 'j'
            | 'k' | 'l' | 'm' | 'n' | 'o' | 'p' | 'q' | 'r' | 's' | 't'
            | 'u' | 'v' | 'w' | 'x' | 'y' | 'z'
            | '_' ;
OCTAL       = '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' ;
DIGIT       = OCTAL | '8' | '9' ;
HEX         = DIGIT
            | 'A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'a' | 'b' | 'c' | 'd'
            | 'e' | 'f' ;
CHAR        = ? any character included in the Unicode character set ? ;
ESCAPE_CHAR = '\' | "'" | '"' | 'b' | 'n' | 'r' | 't' ;
