package homescript

import (
	"fmt"
	"strings"

	"github.com/smarthome-go/homescript/homescript/errors"
)

type AnalyzerValueType uint8

const (
	AnalyzerTypeNull AnalyzerValueType = iota
	AnalyzerTypeNumber
	AnalyzerTypeBoolean
	AnalyzerTypeString
	AnalyzerTypePair
	AnalyzerTypeObject
	AnalyzerTypeFunction
	AnalyzerTypeBuiltinFunction
	AnalyzerTypeBuiltinVariable
)

func (self AnalyzerValueType) String() string {
	switch self {
	case AnalyzerTypeNull:
		return "null"
	case AnalyzerTypeNumber:
		return "number"
	case AnalyzerTypeBoolean:
		return "boolean"
	case AnalyzerTypeString:
		return "string"
	case AnalyzerTypePair:
		return "pair"
	case AnalyzerTypeObject:
		return "object"
	case AnalyzerTypeFunction, AnalyzerTypeBuiltinFunction:
		return "function"
	case AnalyzerTypeBuiltinVariable:
		return "builtinVariable"
	default:
		// Unreachable
		panic("BUG: A new type was introduced without updating this code")
	}
}

// Value interfaces
type AnalyzerValue interface {
	Type() AnalyzerValueType
	Protected() bool
	Span() errors.Span
	Fields() map[string]AnalyzerValue
	// Is also used for `as str` and printing
	Display(executor Executor, span errors.Span) (string, *errors.Error)
	Debug(executor Executor, span errors.Span) (string, *errors.Error)
	IsTrue(executor Executor, span errors.Span) (bool, *errors.Error)
	IsEqual(executor Executor, span errors.Span, other AnalyzerValue) (bool, *errors.Error)
}

type AnalyzerValueRelational interface {
	IsLessThan(executor Executor, span errors.Span, other AnalyzerValue) (bool, *errors.Error)
	IsLessThanOrEqual(executor Executor, span errors.Span, other AnalyzerValue) (bool, *errors.Error)
	IsGreaterThan(executor Executor, span errors.Span, other AnalyzerValue) (bool, *errors.Error)
	IsGreaterThanOrEqual(executor Executor, span errors.Span, other AnalyzerValue) (bool, *errors.Error)
}

type AnalyzerValueAlg interface {
	Add(executor Executor, span errors.Span, other AnalyzerValue) (AnalyzerValue, *errors.Error)
	Sub(executor Executor, span errors.Span, other AnalyzerValue) (AnalyzerValue, *errors.Error)
	Mul(executor Executor, span errors.Span, other AnalyzerValue) (AnalyzerValue, *errors.Error)
	Div(executor Executor, span errors.Span, other AnalyzerValue) (AnalyzerValue, *errors.Error)
	IntDiv(executor Executor, span errors.Span, other AnalyzerValue) (AnalyzerValue, *errors.Error)
	Rem(executor Executor, span errors.Span, other AnalyzerValue) (AnalyzerValue, *errors.Error)
	Pow(executor Executor, span errors.Span, other AnalyzerValue) (AnalyzerValue, *errors.Error)
}

// Null value
type AnalyzerValueNull struct {
	Range       errors.Span
	IsProtected bool
}

func (self AnalyzerValueNull) Type() AnalyzerValueType { return AnalyzerTypeNull }
func (self AnalyzerValueNull) Span() errors.Span       { return self.Range }
func (self AnalyzerValueNull) Fields() map[string]AnalyzerValue {
	return make(map[string]AnalyzerValue)
}
func (self AnalyzerValueNull) Protected() bool { return self.IsProtected }
func (self AnalyzerValueNull) Display(_ Executor, _ errors.Span) (string, *errors.Error) {
	return "null", nil
}
func (self AnalyzerValueNull) Debug(_ Executor, _ errors.Span) (string, *errors.Error) {
	return "null", nil
}
func (self AnalyzerValueNull) IsTrue(_ Executor, _ errors.Span) (bool, *errors.Error) {
	return false, nil
}
func (self AnalyzerValueNull) IsEqual(_ Executor, _ errors.Span, other AnalyzerValue) (bool, *errors.Error) {
	return false, nil
}

// Boolean value
type AnalyzerValueBool struct {
	Value       bool
	Range       errors.Span
	IsProtected bool
}

func (self AnalyzerValueBool) Type() AnalyzerValueType { return AnalyzerTypeBoolean }
func (self AnalyzerValueBool) Span() errors.Span       { return self.Range }
func (self AnalyzerValueBool) Fields() map[string]AnalyzerValue {
	return make(map[string]AnalyzerValue)
}
func (self AnalyzerValueBool) Protected() bool { return self.IsProtected }
func (self AnalyzerValueBool) Display(_ Executor, _ errors.Span) (string, *errors.Error) {
	return fmt.Sprintf("%t", self.Value), nil
}
func (self AnalyzerValueBool) Debug(_ Executor, _ errors.Span) (string, *errors.Error) {
	return fmt.Sprintf("%t", self.Value), nil
}
func (self AnalyzerValueBool) IsTrue(_ Executor, _ errors.Span) (bool, *errors.Error) {
	return self.Value, nil
}
func (self AnalyzerValueBool) IsEqual(_ Executor, span errors.Span, other AnalyzerValue) (bool, *errors.Error) {
	if self.Type() != other.Type() {
		return false, errors.NewError(
			span,
			fmt.Sprintf("cannot compare %v to %v", self.Type(), other.Type()),
			errors.TypeError,
		)
	}
	return self.Value == other.(AnalyzerValueBool).Value, nil
}

func (self AnalyzerValueBool) Add(executor Executor, span errors.Span, other AnalyzerValue) (AnalyzerValue, *errors.Error) {
	switch other.Type() {
	case AnalyzerTypeString:
		// Convert the boolean to a display representation
		display, err := self.Display(executor, span)
		if err != nil {
			return nil, err
		}
		// Return a string concatonation
		return AnalyzerValueString{Value: display + other.(AnalyzerValueString).Value}, nil
	case AnalyzerTypeBuiltinVariable:
		otherCallback, err := other.(AnalyzerValueBuiltinVariable).Callback(executor, span)
		if err != nil {
			return nil, err
		}
		self.Add(executor, span, otherCallback)
	}
	return nil, errors.NewError(span, fmt.Sprintf("cannot add %v to %v", other.Type(), self.Type()), errors.TypeError)
}
func (self AnalyzerValueBool) Sub(executor Executor, span errors.Span, other AnalyzerValue) (AnalyzerValue, *errors.Error) {
	return nil, errors.NewError(span, fmt.Sprintf("Unsupported operation on type %v", self.Type()), errors.TypeError)
}
func (self AnalyzerValueBool) Mul(executor Executor, span errors.Span, other AnalyzerValue) (AnalyzerValue, *errors.Error) {
	return nil, errors.NewError(span, fmt.Sprintf("Unsupported operation on type %v", self.Type()), errors.TypeError)
}
func (self AnalyzerValueBool) Div(executor Executor, span errors.Span, other AnalyzerValue) (AnalyzerValue, *errors.Error) {
	return nil, errors.NewError(span, fmt.Sprintf("Unsupported operation on type %v", self.Type()), errors.TypeError)
}
func (self AnalyzerValueBool) IntDiv(executor Executor, span errors.Span, other AnalyzerValue) (AnalyzerValue, *errors.Error) {
	return nil, errors.NewError(span, fmt.Sprintf("Unsupported operation on type %v", self.Type()), errors.TypeError)
}
func (self AnalyzerValueBool) Rem(executor Executor, span errors.Span, other AnalyzerValue) (AnalyzerValue, *errors.Error) {
	return nil, errors.NewError(span, fmt.Sprintf("Unsupported operation on type %v", self.Type()), errors.TypeError)
}
func (self AnalyzerValueBool) Pow(executor Executor, span errors.Span, other AnalyzerValue) (AnalyzerValue, *errors.Error) {
	return nil, errors.NewError(span, fmt.Sprintf("Unsupported operation on type %v", self.Type()), errors.TypeError)
}

// Pair value
type AnalyzerValuePair struct {
	Key         string
	Value       AnalyzerValue
	Range       errors.Span
	IsProtected bool
}

func (self AnalyzerValuePair) Type() AnalyzerValueType  { return AnalyzerTypePair }
func (self AnalyzerValuePair) Span() errors.Span        { return self.Range }
func (self AnalyzerValuePair) Fields() map[string]Value { return make(map[string]AnalyzerValue) }
func (self AnalyzerValuePair) Protected() bool          { return self.IsProtected }
func (self AnalyzerValuePair) Display(executor Executor, span errors.Span) (string, *errors.Error) {
	value, err := self.Value.Display(executor, span)
	if err != nil {
		return "", err
	}
	return fmt.Sprintf("%s => %s", self.Key, value), nil
}
func (self AnalyzerValuePair) Debug(executor Executor, span errors.Span) (string, *errors.Error) {
	value, err := self.Value.Debug(executor, span)
	if err != nil {
		return "", err
	}
	return fmt.Sprintf("(Key: %s | Value: %s)", self.Key, value), nil
}
func (self AnalyzerValuePair) IsTrue(executor Executor, span errors.Span) (bool, *errors.Error) {
	value, err := self.Value.IsTrue(executor, span)
	if err != nil {
		return false, err
	}
	return self.Key != "" && value, nil
}
func (self AnalyzerValuePair) IsEqual(executor Executor, span errors.Span, other AnalyzerValue) (bool, *errors.Error) {
	if self.Type() != other.Type() {
		return false, errors.NewError(
			span,
			fmt.Sprintf("cannot compare %v to %v", self.Type(), other.Type()),
			errors.TypeError,
		)
	}
	value, err := self.Value.IsEqual(executor, span, other.(AnalyzerValuePair).Value)
	if err != nil {
		return false, err
	}
	return self.Key == other.(AnalyzerValuePair).Key && value, nil
}

// Object value
type ValueObject struct {
	// Can be used if a builtin function only accepts objects of a certain type
	DataType string
	// Specifies whether this object is dynamic
	// If it is dynamic, the analyzer will not run its field checks
	// Such a dynamic object could be the global `ARGS` object
	IsDynamic bool
	// The fields of the object
	ObjFields   map[string]Value
	Range       errors.Span
	IsProtected bool
}

func (self ValueObject) Type() ValueType          { return TypeObject }
func (self ValueObject) Span() errors.Span        { return self.Range }
func (self ValueObject) Fields() map[string]Value { return self.ObjFields }
func (self ValueObject) Protected() bool          { return self.IsProtected }
func (self ValueObject) Display(executor Executor, span errors.Span) (string, *errors.Error) {
	fields := make([]string, 0)
	for key, value := range self.ObjFields {
		valueDisplay, err := value.Display(executor, span)
		if err != nil {
			return "", err
		}
		fields = append(fields, fmt.Sprintf("%s: %s", key, valueDisplay))
	}
	return fmt.Sprintf("{%s}", strings.Join(fields, "; ")), nil
}
func (self ValueObject) Debug(executor Executor, span errors.Span) (string, *errors.Error) {
	fields := make([]string, 0)
	for key, value := range self.ObjFields {
		valueDisplay, err := value.Display(executor, span)
		if err != nil {
			return "", err
		}
		fields = append(fields, fmt.Sprintf("\t%s: %s", key, valueDisplay))
	}
	return fmt.Sprintf("{\n%s\n}", strings.Join(fields, "\n")), nil
}
func (self ValueObject) IsTrue(executor Executor, span errors.Span) (bool, *errors.Error) {
	for _, value := range self.ObjFields {
		valueTrue, err := value.IsTrue(executor, span)
		if err != nil {
			return false, err
		}
		if !valueTrue {
			return false, nil
		}
	}
	return true, nil
}
func (self ValueObject) IsEqual(executor Executor, span errors.Span, other AnalyzerValue) (bool, *errors.Error) {
	if self.Type() != other.Type() {
		return false, errors.NewError(
			span,
			fmt.Sprintf("cannot compare %v to %v", self.Type(), other.Type()),
			errors.TypeError,
		)
	}
	if len(self.ObjFields) != len(other.(ValueObject).ObjFields) {
		return false, nil
	}
	for key, value := range self.ObjFields {
		eq, err := other.(ValueObject).ObjFields[key].IsEqual(executor, span, value)
		if err != nil {
			return false, err
		}
		if !eq {
			return false, nil
		}
	}
	return true, nil
}

// Function value
type ValueFunction struct {
	Identifier *string
	Args       []struct {
		Identifier string
		Span       errors.Span
	}
	Body        []Statement
	Range       errors.Span
	IsProtected bool
}

func (self ValueFunction) Type() ValueType          { return TypeFunction }
func (self ValueFunction) Span() errors.Span        { return self.Range }
func (self ValueFunction) Fields() map[string]Value { return make(map[string]Value) }
func (self ValueFunction) Protected() bool          { return self.IsProtected }
func (self ValueFunction) Display(_ Executor, _ errors.Span) (string, *errors.Error) {
	return "<function>", nil
}
func (self ValueFunction) Debug(_ Executor, _ errors.Span) (string, *errors.Error) {
	return "<function>", nil
}
func (self ValueFunction) IsTrue(_ Executor, _ errors.Span) (bool, *errors.Error) {
	return true, nil
}
func (self ValueFunction) IsEqual(_ Executor, span errors.Span, other AnalyzerValue) (bool, *errors.Error) {
	if self.Type() != other.Type() {
		return false, errors.NewError(
			span,
			fmt.Sprintf("cannot compare %v to %v", self.Type(), other.Type()),
			errors.TypeError,
		)
	}
	return false, nil
}

// Builtin function value
type ValueBuiltinFunction struct {
	Callback func(executor Executor, span errors.Span, args ...Value) (Value, *int, *errors.Error)
}

func (self ValueBuiltinFunction) Type() ValueType          { return TypeBuiltinFunction }
func (self ValueBuiltinFunction) Span() errors.Span        { return errors.Span{} }
func (self ValueBuiltinFunction) Fields() map[string]Value { return make(map[string]Value) }
func (self ValueBuiltinFunction) Protected() bool          { return true }
func (self ValueBuiltinFunction) Display(_ Executor, _ errors.Span) (string, *errors.Error) {
	return "<builtin-function>", nil
}
func (self ValueBuiltinFunction) Debug(_ Executor, _ errors.Span) (string, *errors.Error) {
	return "<builtin-function>", nil
}
func (self ValueBuiltinFunction) IsTrue(_ Executor, _ errors.Span) (bool, *errors.Error) {
	return true, nil
}
func (self ValueBuiltinFunction) IsEqual(executor Executor, span errors.Span, other AnalyzerValue) (bool, *errors.Error) {
	if self.Type() != other.Type() && other.Type() != TypeFunction {
		return false, errors.NewError(
			span,
			fmt.Sprintf("cannot compare %v to %v", self.Type(), other.Type()),
			errors.TypeError,
		)
	}
	return false, nil
}

// Builtin variable value
type ValueBuiltinVariable struct {
	Callback func(executor Executor, span errors.Span) (Value, *errors.Error)
}

func (self ValueBuiltinVariable) Type() ValueType          { return TypeBuiltinVariable }
func (self ValueBuiltinVariable) Span() errors.Span        { return errors.Span{} }
func (self ValueBuiltinVariable) Fields() map[string]Value { return make(map[string]Value) }
func (self ValueBuiltinVariable) Protected() bool {
	panic("A bare builtin variable should not exist")
}
func (self ValueBuiltinVariable) Display(executor Executor, span errors.Span) (string, *errors.Error) {
	panic("A bare builtin variable should not exist")
}
func (self ValueBuiltinVariable) Debug(executor Executor, span errors.Span) (string, *errors.Error) {
	panic("A bare builtin variable should not exist")
}
func (self ValueBuiltinVariable) IsTrue(executor Executor, span errors.Span) (bool, *errors.Error) {
	panic("A bare builtin variable should not exist")
}
func (self ValueBuiltinVariable) IsEqual(executor Executor, span errors.Span, other AnalyzerValue) (bool, *errors.Error) {
	panic("A bare builtin variable should not exist")
}
func (self ValueBuiltinVariable) IsLessThan(executor Executor, span errors.Span, other AnalyzerValue) (bool, *errors.Error) {
	panic("A bare builtin variable should not exist")
}
func (self ValueBuiltinVariable) IsLessThanOrEqual(executor Executor, span errors.Span, other AnalyzerValue) (bool, *errors.Error) {
	panic("A bare builtin variable should not exist")
}
func (self ValueBuiltinVariable) IsGreaterThan(executor Executor, span errors.Span, other AnalyzerValue) (bool, *errors.Error) {
	panic("A bare builtin variable should not exist")
}
func (self ValueBuiltinVariable) IsGreaterThanOrEqual(executor Executor, span errors.Span, other AnalyzerValue) (bool, *errors.Error) {
	panic("A bare builtin variable should not exist")
}

func (self ValueBuiltinVariable) Add(executor Executor, span errors.Span, other AnalyzerValue) (Value, *errors.Error) {
	panic("A bare builtin variable should not exist")
}

func (self ValueBuiltinVariable) Sub(executor Executor, span errors.Span, other AnalyzerValue) (Value, *errors.Error) {
	panic("A bare builtin variable should not exist")
}
func (self ValueBuiltinVariable) Mul(executor Executor, span errors.Span, other AnalyzerValue) (Value, *errors.Error) {
	panic("A bare builtin variable should not exist")
}
func (self ValueBuiltinVariable) Div(executor Executor, span errors.Span, other AnalyzerValue) (Value, *errors.Error) {
	panic("A bare builtin variable should not exist")
}
func (self ValueBuiltinVariable) IntDiv(executor Executor, span errors.Span, other AnalyzerValue) (Value, *errors.Error) {
	panic("A bare builtin variable should not exist")
}
func (self ValueBuiltinVariable) Rem(executor Executor, span errors.Span, other AnalyzerValue) (Value, *errors.Error) {
	panic("A bare builtin variable should not exist")
}
func (self ValueBuiltinVariable) Pow(executor Executor, span errors.Span, other AnalyzerValue) (Value, *errors.Error) {
	panic("A bare builtin variable should not exist")
}

// Helper functions for values
func getField(executor Executor, span errors.Span, self Value, fieldKey string) (Value, *errors.Error) {
	value, exists := self.Fields()[fieldKey]
	if !exists {
		return nil, errors.NewError(span, fmt.Sprintf("%v has no member named %s", self.Type(), fieldKey), errors.TypeError)
	}
	return value, nil
}

// Helper factory functions
func makeNull(span errors.Span) Value {
	return AnalyzerValueNull{Range: span}
}

func makeNullResult(span errors.Span) Result {
	null := makeNull(span)
	return Result{Value: &null}
}

func makeBool(span errors.Span, value bool) Value {
	return AnalyzerValueBool{Value: value, Range: span}
}

func makeBoolResult(span errors.Span, value bool) Result {
	bool := makeBool(span, value)
	return Result{Value: &bool}
}

func makeNum(span errors.Span, value float64) Value {
	return ValueNumber{Value: value, Range: span}
}

func makeStr(span errors.Span, value string) Value {
	return ValueString{Value: value, Range: span}
}

func makePair(span errors.Span, key string, value Value) Value {
	return AnalyzerValuePair{Key: key, Value: value, Range: span}
}

func makeFn(identifier *string, span errors.Span) Value {
	return ValueFunction{Identifier: identifier, Range: span}
}

func valPtr(input Value) *Value {
	return &input
}
